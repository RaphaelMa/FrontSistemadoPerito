{"ast":null,"code":"(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport { isHTMLElement } from \"./instanceOf.js\";\nimport { round } from \"../utils/math.js\";\nexport default function getBoundingClientRect(element, includeScale) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  var rect = element.getBoundingClientRect();\n  var scaleX = 1;\n  var scaleY = 1;\n\n  if (isHTMLElement(element) && includeScale) {\n    var offsetHeight = element.offsetHeight;\n    var offsetWidth = element.offsetWidth; // Do not attempt to divide by 0, otherwise we get `Infinity` as scale\n    // Fallback to 1 in case both values are `0`\n\n    if (offsetWidth > 0) {\n      scaleX = round(rect.width) / offsetWidth || 1;\n    }\n\n    if (offsetHeight > 0) {\n      scaleY = round(rect.height) / offsetHeight || 1;\n    }\n  }\n\n  return {\n    width: rect.width / scaleX,\n    height: rect.height / scaleY,\n    top: rect.top / scaleY,\n    right: rect.right / scaleX,\n    bottom: rect.bottom / scaleY,\n    left: rect.left / scaleX,\n    x: rect.left / scaleX,\n    y: rect.top / scaleY\n  };\n}\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(getBoundingClientRect, \"getBoundingClientRect\", \"/Users/raphael/Documents/Github/FrontSistemadoPerito/node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"sources":["/Users/raphael/Documents/Github/FrontSistemadoPerito/node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js"],"names":["isHTMLElement","round","getBoundingClientRect","element","includeScale","rect","scaleX","scaleY","offsetHeight","offsetWidth","width","height","top","right","bottom","left","x","y"],"mappings":";;;;;;;;;AAAA,SAASA,aAAT,QAA8B,iBAA9B;AACA,SAASC,KAAT,QAAsB,kBAAtB;AACA,eAAe,SAASC,qBAAT,CAA+BC,OAA/B,EAAwCC,YAAxC,EAAsD;AACnE,MAAIA,YAAY,KAAK,KAAK,CAA1B,EAA6B;AAC3BA,IAAAA,YAAY,GAAG,KAAf;AACD;;AAED,MAAIC,IAAI,GAAGF,OAAO,CAACD,qBAAR,EAAX;AACA,MAAII,MAAM,GAAG,CAAb;AACA,MAAIC,MAAM,GAAG,CAAb;;AAEA,MAAIP,aAAa,CAACG,OAAD,CAAb,IAA0BC,YAA9B,EAA4C;AAC1C,QAAII,YAAY,GAAGL,OAAO,CAACK,YAA3B;AACA,QAAIC,WAAW,GAAGN,OAAO,CAACM,WAA1B,CAF0C,CAEH;AACvC;;AAEA,QAAIA,WAAW,GAAG,CAAlB,EAAqB;AACnBH,MAAAA,MAAM,GAAGL,KAAK,CAACI,IAAI,CAACK,KAAN,CAAL,GAAoBD,WAApB,IAAmC,CAA5C;AACD;;AAED,QAAID,YAAY,GAAG,CAAnB,EAAsB;AACpBD,MAAAA,MAAM,GAAGN,KAAK,CAACI,IAAI,CAACM,MAAN,CAAL,GAAqBH,YAArB,IAAqC,CAA9C;AACD;AACF;;AAED,SAAO;AACLE,IAAAA,KAAK,EAAEL,IAAI,CAACK,KAAL,GAAaJ,MADf;AAELK,IAAAA,MAAM,EAAEN,IAAI,CAACM,MAAL,GAAcJ,MAFjB;AAGLK,IAAAA,GAAG,EAAEP,IAAI,CAACO,GAAL,GAAWL,MAHX;AAILM,IAAAA,KAAK,EAAER,IAAI,CAACQ,KAAL,GAAaP,MAJf;AAKLQ,IAAAA,MAAM,EAAET,IAAI,CAACS,MAAL,GAAcP,MALjB;AAMLQ,IAAAA,IAAI,EAAEV,IAAI,CAACU,IAAL,GAAYT,MANb;AAOLU,IAAAA,CAAC,EAAEX,IAAI,CAACU,IAAL,GAAYT,MAPV;AAQLW,IAAAA,CAAC,EAAEZ,IAAI,CAACO,GAAL,GAAWL;AART,GAAP;AAUD;;;;;;;;;;0BAjCuBL,qB","sourcesContent":["import { isHTMLElement } from \"./instanceOf.js\";\nimport { round } from \"../utils/math.js\";\nexport default function getBoundingClientRect(element, includeScale) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  var rect = element.getBoundingClientRect();\n  var scaleX = 1;\n  var scaleY = 1;\n\n  if (isHTMLElement(element) && includeScale) {\n    var offsetHeight = element.offsetHeight;\n    var offsetWidth = element.offsetWidth; // Do not attempt to divide by 0, otherwise we get `Infinity` as scale\n    // Fallback to 1 in case both values are `0`\n\n    if (offsetWidth > 0) {\n      scaleX = round(rect.width) / offsetWidth || 1;\n    }\n\n    if (offsetHeight > 0) {\n      scaleY = round(rect.height) / offsetHeight || 1;\n    }\n  }\n\n  return {\n    width: rect.width / scaleX,\n    height: rect.height / scaleY,\n    top: rect.top / scaleY,\n    right: rect.right / scaleX,\n    bottom: rect.bottom / scaleY,\n    left: rect.left / scaleX,\n    x: rect.left / scaleX,\n    y: rect.top / scaleY\n  };\n}"]},"metadata":{},"sourceType":"module"}