{"ast":null,"code":"(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useRef, useState, useEffect } from 'react';\nimport raf from 'raf';\nexport default function useRaf(callback) {\n  var rafRef = useRef();\n  var removedRef = useRef(false);\n\n  function trigger() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (!removedRef.current) {\n      raf.cancel(rafRef.current);\n      rafRef.current = raf(function () {\n        callback.apply(void 0, args);\n      });\n    }\n  }\n\n  useEffect(function () {\n    return function () {\n      removedRef.current = true;\n      raf.cancel(rafRef.current);\n    };\n  }, []);\n  return trigger;\n}\n\n__signature__(useRaf, \"useRef{rafRef}\\nuseRef{removedRef}\\nuseEffect{}\");\n\nexport function useRafState(defaultState) {\n  var batchRef = useRef([]);\n\n  var _useState = useState({}),\n      _useState2 = _slicedToArray(_useState, 2),\n      forceUpdate = _useState2[1];\n\n  var state = useRef(typeof defaultState === 'function' ? defaultState() : defaultState);\n  var flushUpdate = useRaf(function () {\n    var current = state.current;\n    batchRef.current.forEach(function (callback) {\n      current = callback(current);\n    });\n    batchRef.current = [];\n    state.current = current;\n    forceUpdate({});\n  });\n\n  function updater(callback) {\n    batchRef.current.push(callback);\n    flushUpdate();\n  }\n\n  return [state.current, updater];\n}\n\n__signature__(useRafState, \"useRef{batchRef}\\nuseState{_useState({})}\\nuseRef{state}\\nuseRaf{flushUpdate}\", () => [useRaf]);\n\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(useRaf, \"useRaf\", \"/Users/raphael/Documents/Github/FrontSistemadoPerito/node_modules/rc-tabs/es/hooks/useRaf.js\");\n  reactHotLoader.register(useRafState, \"useRafState\", \"/Users/raphael/Documents/Github/FrontSistemadoPerito/node_modules/rc-tabs/es/hooks/useRaf.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"sources":["/Users/raphael/Documents/Github/FrontSistemadoPerito/node_modules/rc-tabs/es/hooks/useRaf.js"],"names":["_slicedToArray","useRef","useState","useEffect","raf","useRaf","callback","rafRef","removedRef","trigger","_len","arguments","length","args","Array","_key","current","cancel","apply","useRafState","defaultState","batchRef","_useState","_useState2","forceUpdate","state","flushUpdate","forEach","updater","push"],"mappings":";;;;;;;;;AAAA,OAAOA,cAAP,MAA2B,0CAA3B;AACA,SAASC,MAAT,EAAiBC,QAAjB,EAA2BC,SAA3B,QAA4C,OAA5C;AACA,OAAOC,GAAP,MAAgB,KAAhB;AACA,eAAe,SAASC,MAAT,CAAgBC,QAAhB,EAA0B;AACvC,MAAIC,MAAM,GAAGN,MAAM,EAAnB;AACA,MAAIO,UAAU,GAAGP,MAAM,CAAC,KAAD,CAAvB;;AAEA,WAASQ,OAAT,GAAmB;AACjB,SAAK,IAAIC,IAAI,GAAGC,SAAS,CAACC,MAArB,EAA6BC,IAAI,GAAG,IAAIC,KAAJ,CAAUJ,IAAV,CAApC,EAAqDK,IAAI,GAAG,CAAjE,EAAoEA,IAAI,GAAGL,IAA3E,EAAiFK,IAAI,EAArF,EAAyF;AACvFF,MAAAA,IAAI,CAACE,IAAD,CAAJ,GAAaJ,SAAS,CAACI,IAAD,CAAtB;AACD;;AAED,QAAI,CAACP,UAAU,CAACQ,OAAhB,EAAyB;AACvBZ,MAAAA,GAAG,CAACa,MAAJ,CAAWV,MAAM,CAACS,OAAlB;AACAT,MAAAA,MAAM,CAACS,OAAP,GAAiBZ,GAAG,CAAC,YAAY;AAC/BE,QAAAA,QAAQ,CAACY,KAAT,CAAe,KAAK,CAApB,EAAuBL,IAAvB;AACD,OAFmB,CAApB;AAGD;AACF;;AAEDV,EAAAA,SAAS,CAAC,YAAY;AACpB,WAAO,YAAY;AACjBK,MAAAA,UAAU,CAACQ,OAAX,GAAqB,IAArB;AACAZ,MAAAA,GAAG,CAACa,MAAJ,CAAWV,MAAM,CAACS,OAAlB;AACD,KAHD;AAID,GALQ,EAKN,EALM,CAAT;AAMA,SAAOP,OAAP;AACD;;cAxBuBJ,M;;AAyBxB,OAAO,SAASc,WAAT,CAAqBC,YAArB,EAAmC;AACxC,MAAIC,QAAQ,GAAGpB,MAAM,CAAC,EAAD,CAArB;;AAEA,MAAIqB,SAAS,GAAGpB,QAAQ,CAAC,EAAD,CAAxB;AAAA,MACIqB,UAAU,GAAGvB,cAAc,CAACsB,SAAD,EAAY,CAAZ,CAD/B;AAAA,MAEIE,WAAW,GAAGD,UAAU,CAAC,CAAD,CAF5B;;AAIA,MAAIE,KAAK,GAAGxB,MAAM,CAAC,OAAOmB,YAAP,KAAwB,UAAxB,GAAqCA,YAAY,EAAjD,GAAsDA,YAAvD,CAAlB;AACA,MAAIM,WAAW,GAAGrB,MAAM,CAAC,YAAY;AACnC,QAAIW,OAAO,GAAGS,KAAK,CAACT,OAApB;AACAK,IAAAA,QAAQ,CAACL,OAAT,CAAiBW,OAAjB,CAAyB,UAAUrB,QAAV,EAAoB;AAC3CU,MAAAA,OAAO,GAAGV,QAAQ,CAACU,OAAD,CAAlB;AACD,KAFD;AAGAK,IAAAA,QAAQ,CAACL,OAAT,GAAmB,EAAnB;AACAS,IAAAA,KAAK,CAACT,OAAN,GAAgBA,OAAhB;AACAQ,IAAAA,WAAW,CAAC,EAAD,CAAX;AACD,GARuB,CAAxB;;AAUA,WAASI,OAAT,CAAiBtB,QAAjB,EAA2B;AACzBe,IAAAA,QAAQ,CAACL,OAAT,CAAiBa,IAAjB,CAAsBvB,QAAtB;AACAoB,IAAAA,WAAW;AACZ;;AAED,SAAO,CAACD,KAAK,CAACT,OAAP,EAAgBY,OAAhB,CAAP;AACD;;cAxBeT,W,0FAQId,M;;;;;;;;;;;0BAjCIA,M;0BAyBRc,W","sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useRef, useState, useEffect } from 'react';\nimport raf from 'raf';\nexport default function useRaf(callback) {\n  var rafRef = useRef();\n  var removedRef = useRef(false);\n\n  function trigger() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (!removedRef.current) {\n      raf.cancel(rafRef.current);\n      rafRef.current = raf(function () {\n        callback.apply(void 0, args);\n      });\n    }\n  }\n\n  useEffect(function () {\n    return function () {\n      removedRef.current = true;\n      raf.cancel(rafRef.current);\n    };\n  }, []);\n  return trigger;\n}\nexport function useRafState(defaultState) {\n  var batchRef = useRef([]);\n\n  var _useState = useState({}),\n      _useState2 = _slicedToArray(_useState, 2),\n      forceUpdate = _useState2[1];\n\n  var state = useRef(typeof defaultState === 'function' ? defaultState() : defaultState);\n  var flushUpdate = useRaf(function () {\n    var current = state.current;\n    batchRef.current.forEach(function (callback) {\n      current = callback(current);\n    });\n    batchRef.current = [];\n    state.current = current;\n    forceUpdate({});\n  });\n\n  function updater(callback) {\n    batchRef.current.push(callback);\n    flushUpdate();\n  }\n\n  return [state.current, updater];\n}"]},"metadata":{},"sourceType":"module"}