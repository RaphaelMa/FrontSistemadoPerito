{"ast":null,"code":"(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport getNodeName from \"./getNodeName.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport { isShadowRoot } from \"./instanceOf.js\";\nexport default function getParentNode(element) {\n  if (getNodeName(element) === 'html') {\n    return element;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || ( // DOM Element detected\n    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    getDocumentElement(element) // fallback\n\n  );\n}\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(getParentNode, \"getParentNode\", \"/Users/raphael/Documents/Github/FrontSistemadoPerito/node_modules/@popperjs/core/lib/dom-utils/getParentNode.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"sources":["/Users/raphael/Documents/Github/FrontSistemadoPerito/node_modules/@popperjs/core/lib/dom-utils/getParentNode.js"],"names":["getNodeName","getDocumentElement","isShadowRoot","getParentNode","element","assignedSlot","parentNode","host"],"mappings":";;;;;;;;;AAAA,OAAOA,WAAP,MAAwB,kBAAxB;AACA,OAAOC,kBAAP,MAA+B,yBAA/B;AACA,SAASC,YAAT,QAA6B,iBAA7B;AACA,eAAe,SAASC,aAAT,CAAuBC,OAAvB,EAAgC;AAC7C,MAAIJ,WAAW,CAACI,OAAD,CAAX,KAAyB,MAA7B,EAAqC;AACnC,WAAOA,OAAP;AACD;;AAED,SAAQ;AACN;AACA;AACAA,IAAAA,OAAO,CAACC,YAAR,IAAwB;AACxBD,IAAAA,OAAO,CAACE,UADR,MACwB;AACxBJ,IAAAA,YAAY,CAACE,OAAD,CAAZ,GAAwBA,OAAO,CAACG,IAAhC,GAAuC,IAFvC,KAEgD;AAChD;AACAN,IAAAA,kBAAkB,CAACG,OAAD,CAPpB,CAO8B;;AAP9B;AAUD;;;;;;;;;;0BAfuBD,a","sourcesContent":["import getNodeName from \"./getNodeName.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport { isShadowRoot } from \"./instanceOf.js\";\nexport default function getParentNode(element) {\n  if (getNodeName(element) === 'html') {\n    return element;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || ( // DOM Element detected\n    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    getDocumentElement(element) // fallback\n\n  );\n}"]},"metadata":{},"sourceType":"module"}